#version 450
#include "constants.glsl"

#define WORKGROUP_SIZE 8

layout (local_size_x=WORKGROUP_SIZE, local_size_y=WORKGROUP_SIZE, local_size_z=1) in;

// NOTE: padding is required in the corresponding CPU struct
struct Vertex
{
    vec3 pos;      /* position */
    vec3 normal;   /* normal vector */
    vec2 uv;       /* tex coords */
    uint alpha;    /* transparency value */
};

layout(std140, push_constant) uniform Push {
    uvec3 n_vertices; // number of vertices in each dimension
} push;

layout(std140, binding = 0) buffer buf {
   Vertex vertex[];
};

layout (std140, binding = 1) uniform UBO {
    float t;
} ubo;

uint get_vert_idx(uvec3 idx) {
    uvec3 nv = push.n_vertices;
    return nv.x * idx.y + idx.x;
}

vec3 get_pos(uvec3 idx) {
    uint vidx = get_vert_idx(idx);
    return vertex[vidx].pos;
}

void main() {
    uvec3 nv = push.n_vertices;
    uvec3 idx = gl_GlobalInvocationID;
    if (idx.x >= nv.x || idx.y >= nv.y)
        return;
    uint vidx = get_vert_idx(idx);

    float x = vertex[vidx].pos.x;
    float z = vertex[vidx].pos.z;

    float t = .1 * ubo.t;
    vertex[vidx].pos.y = .25 * sin(M_2PI * t) * sin(10 * (x - t)) * cos(10 * (z - t));

    vec3 p0 = get_pos(idx);
    vec3 p1 = get_pos(idx + ivec3(1, 0, 0));
    vec3 p2 = get_pos(idx + ivec3(0, 1, 0));
    vertex[vidx].normal = cross(p1 - p0, p2 - p0);
}
