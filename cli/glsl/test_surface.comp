#version 450
#include "constants.glsl"

#define WORKGROUP_SIZE 8

layout (local_size_x=WORKGROUP_SIZE, local_size_y=WORKGROUP_SIZE, local_size_z=1) in;

// NOTE: padding is required in the corresponding CPU struct
struct Vertex
{
    vec3 pos;      /* position */
    vec3 normal;   /* normal vector */
    vec2 uv;       /* tex coords */
    uint alpha;    /* transparency value */
};

layout(std140, push_constant) uniform Push {
    uvec3 n_vertices; // number of vertices in each dimension
} push;

layout(std140, binding = 0) buffer buf {
   Vertex vertex[];
};

layout(std140, binding = 1) buffer buf_prev {
   vec2 bak[]; // value at prev time step, and at prev prev time step
};

layout (std140, binding = 2) uniform UBO {
    float t;
    float dt;
    int iter;
} ubo;

uint get_vert_idx(uvec3 idx) {
    uvec3 nv = push.n_vertices;
    return nv.x * clamp(idx.y, 0, nv.y - 1) + clamp(idx.x, 0, nv.x - 1);
}

// vec2 get_pos(uvec3 idx) {
//     uint vidx = get_vert_idx(idx);
//     return bak[vidx];
// }

void main() {
    uvec3 nv = push.n_vertices;
    uvec3 idx = gl_GlobalInvocationID;
    if (idx.x >= nv.x || idx.y >= nv.y)
        return;
    uint vidx = get_vert_idx(idx);
    // float t = ubo.t;
    // float dt = .1 * ubo.dt;

    // float c = 1.0;
    // float dx = 20.0 / nv.x;
    // float dy = 20.0 / nv.y;
    // float Cx2 = pow(c * dt / dx, 2);
    // float Cy2 = pow(c * dt / dy, 2);
    // float D1 = 2;
    // float D2 = 1;

    // Prev and prevprev vertex.
    // vec2 p = get_pos(idx);
    // float prev1 = p.x;
    // float prev2 = p.y;

    if (ubo.iter >= 2) return;
    // if (ubo.iter <= 1) {
    //     Cx2 = 0.5 * Cx2;
    //     Cy2 = 0.5 * Cy2;
    //     D1 = 1;
    //     D2 = 0;
    //     prev1 = vertex[vidx].pos.y;
    //     prev2 = vertex[vidx].pos.y;
    // }

    // // Neighbor vertices.
    // float pl = get_pos(idx + ivec3(-1, 0, 0)).x;
    // float pr = get_pos(idx + ivec3(+1, 0, 0)).x;
    // float pu = get_pos(idx + ivec3(0, -1, 0)).x;
    // float pd = get_pos(idx + ivec3(0, +1, 0)).x;

    // float pxx = pl + pr - 2 * prev1;
    // float pyy = pu + pd - 2 * prev1;
    vertex[vidx].pos.y = bak[vidx].x;
    // vertex[vidx].pos.y = D1 * prev1 - D2 * prev2 + Cx2 * pxx + Cy2 * pyy;

    // Update normals.
    uint vidxn = vidx;
    vec3 p0 = vertex[vidxn].pos;
    vidxn = get_vert_idx(idx + ivec3(+1, 0, 0));
    vec3 p1 = vertex[vidxn].pos;
    vidxn = get_vert_idx(idx + ivec3(0, +1, 0));
    vec3 p2 = vertex[vidxn].pos;
    vertex[vidx].normal = cross(p1 - p0, p2 - p0);

    // bak[vidx].y = bak[vidx].x;
    // bak[vidx].x = vertex[vidx].pos.y;
}
